<?php

namespace Sunnysideup\Ecommerce\Forms;

use Psr\SimpleCache\CacheInterface;
use SilverStripe\Control\Controller;
use SilverStripe\Control\Director;
use SilverStripe\Core\Config\Config;
use SilverStripe\Core\Convert;
use SilverStripe\Core\Injector\Injector;
use SilverStripe\Forms\CheckboxField;
use SilverStripe\Forms\FieldList;
use SilverStripe\Forms\Form;
use SilverStripe\Forms\FormAction;
use SilverStripe\Forms\NumericField;
use SilverStripe\Forms\TextField;
use SilverStripe\ORM\DataList;
use SilverStripe\ORM\DataObject;
use SilverStripe\Security\Permission;
use Sunnysideup\Ecommerce\Config\EcommerceConfig;
use Sunnysideup\Ecommerce\Forms\Validation\ProductSearchFormValidator;
use Sunnysideup\Ecommerce\Model\Config\EcommerceDBConfig;
use Sunnysideup\Ecommerce\Model\Search\SearchHistory;
use Sunnysideup\Ecommerce\Model\Search\SearchReplacement;
use Sunnysideup\Ecommerce\Pages\Product;
use Sunnysideup\Ecommerce\Pages\ProductGroup;

use Sunnysideup\Ecommerce\Pages\ProductGroupSearchPage;

/**
 * Product search form
 */
class ProductSearchForm extends Form
{
    /**
     * @var array
     *            List of words to be replaced.
     */
    private const DEBUG_SQL = [
        "\r\n SELECT" => 'SELECT',
        "\r\n FROM" => 'FROM',
        "\r\n WHERE" => 'WHERE',
        "\r\n HAVING" => 'HAVING',
        "\r\n GROUP" => 'GROUP',
        "\r\n ORDER BY" => 'ORDER BY',
        "\r\n INNER JOIN" => 'INNER JOIN',
        "\r\n LEFT JOIN" => 'LEFT JOIN',
    ];

    /**
     * set to TRUE to show the search logic.
     *
     * @var bool
     */
    protected $debug = true;

    /**
     * Fields are:
     * - Keyword
     * - MinimumPrice
     * - MaximumPrice
     *
     * @var array
     */
    protected $rawData = [];

    /**
     * processed keyword
     * @var string
     */
    protected $keywordPhrase = '';

    /**
     * array of IDs of the results found so far.
     *
     * @var array
     */
    protected $productIds = [];

    /**
     * product groups found.
     *
     * @var array
     */
    protected $productGroupIds = [];

    /**
     * Number of results found so far.
     *
<<<<<<< HEAD
     * @var ProductList
=======
     * @var int
>>>>>>> master
     */
    protected $resultArrayPos = 0;

    /**
     * @var SiteTree
     */
    protected $immediateRedirectPage = null;

    /**
     * @var DataList
     */
    protected $baseList = null;

    /**
     * @var int
     */
    protected $productsToSearchCount = 0;

    /**
     * class name of the buyables to search
     * at this stage, you can only search one type of buyable at any one time
     * e.g. only products or only mydataobject.
     *
     * @var string
     */
    protected $baseClassNameForBuyables = Product::class;

    /**
     * class name of the buyables to search
     * at this stage, you can only search one type of buyable at any one time
     * e.g. only products or only mydataobject.
     *
     * @var string
     */
    protected $baseClassNameForGroups = ProductGroup::class;

    // /**
    //  * this is mysql specific, see: https://dev.mysql.com/doc/refman/5.0/en/fulltext-boolean.html.
    //  * not used at the moment!
    //  * @var bool
    //  */
    // protected $useBooleanSearch = true;

    /**
     * get parameters added to the link
     * you dont need to start them with & or ?
     * e.g.
     * a=23&b=234.
     *
     * @var string
     */
    protected $additionalGetParameters = '';

    /**
     * List of additional fields that should be searched full text.
     * We are matching this against the buyable class name.
     *
     * @var array
     */
    protected $extraBuyableFieldsToSearchFullText = [
        Product::class => ['Title', 'MenuTitle', 'Content', 'MetaDescription'],
        ProductGroup::class => ['Title', 'MenuTitle', 'Content', 'MetaDescription'],
        ProductVariation::class => ['FullTitle', 'Description'],
    ];

    /**
<<<<<<< HEAD
     * The method on the parent controller that can display the results of the
     * search results.
     *
     * @var string
     */
    protected $controllerSearchResultDisplayMethod = 'searchresults';
=======
     * Maximum number of results to return
     * we limit this because otherwise the system will choke
     * the assumption is that no user is really interested in looking at
     * tons of results.
     * It defaults to: EcommerceConfig::get("ProductGroup", "maximum_number_of_products_to_list").
     *
     * @var int
     */
    protected $maximumNumberOfResults = 1000;
>>>>>>> master

    /**
     * @var bool
     */
<<<<<<< HEAD
    protected $isShortForm = 0;

    /**
     * List of words to be replaced.
     *
     * @var array
     */
    protected $sqlWords = [
        "\r\n SELECT" => 'SELECT',
        "\r\n FROM" => 'FROM',
        "\r\n WHERE" => 'WHERE',
        "\r\n HAVING" => 'HAVING',
        "\r\n GROUP" => 'GROUP',
        "\r\n ORDER BY" => 'ORDER BY',
        "\r\n INNER JOIN" => 'INNER JOIN',
        "\r\n LEFT JOIN" => 'LEFT JOIN',
    ];
=======
    private static $include_price_filters = false;
>>>>>>> master

    /**
     * ProductsToSearch can be left blank to search all products.
     *
     * @param Controller              $controller                  - associated controller
     * @param string                  $name                        - name of form
     */
    public function __construct($controller, string $name)
    {
<<<<<<< HEAD
        $this->disableSecurityToken();

        if ($productsToSearch) {
            $this->productsToSearch = $productsToSearch;
            $this->productsToSearchCount = $productsToSearch->getRawCount();
        }

        if ($this->isShortForm) {
=======
        //turn of security to allow caching of the form:
        if (Config::inst()->get(ProductSearchForm::class, 'include_price_filters')) {
>>>>>>> master
            $fields = FieldList::create(
                $keywordField = TextField::create('Keyword', _t('ProductSearchForm.KEYWORDS', 'Keywords')),
                NumericField::create('MinimumPrice', _t('ProductSearchForm.MINIMUM_PRICE', 'Minimum Price'))->setScale(2),
                NumericField::create('MaximumPrice', _t('ProductSearchForm.MAXIMUM_PRICE', 'Maximum Price'))->setScale(2)
            );
        } else {
            $fields = FieldList::create(
                $keywordField = TextField::create('Keyword', _t('ProductSearchForm.KEYWORDS', 'Keywords'))
            );
<<<<<<< HEAD

            if ($this->productsToSearcht) {
                $fields->push(
                    CheckboxField::create('SearchOnlyFieldsInThisSection', _t('ProductSearchForm.ONLY_SHOW', 'Only search in') . ' <i>' . $nameOfProductsBeingSearched . '</i> ', true)
                );
            }

            if (Director::isDev() || Permission::check('ADMIN')) {
                $fields->push(CheckboxField::create('DebugSearch', 'Debug Search'));
            }

            $keywordField->setAttribute('placeholder', _t('ProductSearchForm.KEYWORD_PLACEHOLDER', 'search products ...'));
        }

        $requiredFields = [];
        $validator = ProductSearchFormValidator::create($requiredFields);

=======
        }
        $actions = FieldList::create(
            FormAction::create('doProductSearchForm', 'Search')
        );

        if (Director::isDev() || Permission::check('ADMIN')) {
            $fields->push(CheckboxField::create('DebugSearch', 'Debug Search'));
        }
        $keywordField->setAttribute('placeholder', _t('ProductSearchForm.KEYWORD_PLACEHOLDER', 'search products ...'));
        $requiredFields = [];
        $validator = ProductSearchFormValidator::create($requiredFields);
        $this->extend('updateFields', $fields);
        $this->extend('updateActions', $actions);
        $this->extend('updateValidator', $validator);
>>>>>>> master
        parent::__construct($controller, $name, $fields, $actions, $validator);

        $this->setFormMethod('get');
        $this->disableSecurityToken();
<<<<<<< HEAD
        $this->extend('updateFields', $fields);
        $this->setFields($fields);
        $this->extend('updateActions', $actions);
        $this->setActions($actions);
        $this->extend('updateValidator', $validator);
        $this->setValidator($validator);

        $oldData = Controller::curr()->getRequest()->getSession()->get($this->Config()->get('form_data_session_variable'));

        if ($oldData && (is_array($oldData) || is_object($oldData))) {
            $this->loadDataFrom($oldData);
        }

=======
        //extensions need to be set after __construct
        //extension point
>>>>>>> master
        $this->extend('updateProductSearchForm', $this);

        return $this;
    }

<<<<<<< HEAD
    /**
     * @return string
     */
    public function getLastSearchPhase(): string
    {
        $string = '';
        $oldData = $this->getSessionData();

        if ($oldData && (is_array($oldData) || is_object($oldData))) {
            if (isset($oldData['ShortKeyword'])) {
                $string = $oldData['ShortKeyword'];
            } elseif (isset($oldData['Keyword'])) {
                $string = $oldData['Keyword'];
            }
        }
        return trim($string);
    }

    /**
     * @param string $phrase
     */
    public function setLastSearchTerm($phrase)
    {
        $oldData = $this->getOldData();

        if ($oldData && (is_array($oldData) || is_object($oldData))) {
            $oldData['ShortKeyword'] = $phrase;
            $oldData['Keyword'] = $phrase;
        }
=======
    public function getLastSearchPhrase()
    {
        return $this->rawData['Keyword'] ?? '';
    }

    public function getProductIds(): array
    {
        return is_array($this->productIds) ? $this->productIds : [];
    }
>>>>>>> master

    public function getProductGroupIds(): array
    {
        return is_array($this->productGroupIds) ? $this->productGroupIds : [];
    }

    public function setSearchKeyword(string $hash)
    {
<<<<<<< HEAD
        $this->controllerSearchResultDisplayMethod = $s;

        return $this;
=======
        $this->rawData['Keyword'] = urldecode($hash);
        $oldData = $this->applyCacheFromHash($hash);
        if (! empty($oldData['rawData'])) {
            $this->loadDataFrom($oldData['rawData']);
        }
>>>>>>> master
    }

    public function setExtraBuyableFieldsToSearchFullText(array $a)
    {
        $this->extraBuyableFieldsToSearchFullText = $a;
<<<<<<< HEAD

=======
>>>>>>> master
        return $this;
    }

    public function setBaseClassNameForBuyables(string $s)
    {
        $this->baseClassNameForBuyables = $s;
<<<<<<< HEAD

        return $this;
    }

    public function setUseBooleanSearch($b)
    {
        $this->useBooleanSearch = $b;

=======

        return $this;
    }

    public function setMaximumNumberOfResults(int $i)
    {
        $this->maximumNumberOfResults = $i;

>>>>>>> master
        return $this;
    }

    public function setAdditionalGetParameters(string $s)
    {
        $this->additionalGetParameters = $s;

        return $this;
    }

    public function doProductSearchForm($data, $form)
    {
        $this->doProcessSetup($data);

        //basic get

        $this->createBaseList();

        //defining some variables
        $isKeywordSearch = false;
        if ($this->debug) {
            $this->debugOutput('<hr /><h3>BASE LIST</h3><pre>' . str_replace(self::DEBUG_SQL, array_flip(self::DEBUG_SQL), $this->baseList->sql()) . '</pre>');
            $this->debugOutput('<hr /><h3>PRODUCTS IN BASELIST</h3><pre>' . $this->baseList->count() . '</pre>');
        }
        //KEYWORD SEARCH - only bother if we have any keywords and results at all ...
        if ($this->baseList->count()) {
            if (! empty($data['Keyword']) && strlen($this->keywordPhrase) > 1) {
                $this->keywordPhrase = $data['Keyword'];
                $isKeywordSearch = true;
                $this->doKeywordCleanup();
                $this->doAddToSearchHistory();
                $this->doInternalItemSearch();
                $this->doKeywordReplacements();
                $this->doProductSearch();
                $this->doGroupSearch();
            } else {
                $this->addToResults($this->baseList);
            }
        }

        $this->doProcessResults();

        if ($this->immediateRedirectPage) {
            $link = $this->immediateRedirectPage->Link();
            if ($this->debug) {
                $this->debugOutput(
                    '<p style="color: red">Found one answer for potential immediate redirect: ' . $link . '</p>'
                );
            }
        } else {
            $redirectToPage = $this->getResultsPage();
            $hash = $this->setCacheForHash();
            $data['searchcode'] = $hash;
            $link = $redirectToPage->LinkForSearchResults($hash);
            unset($data['action_doProductSearchForm']);
            $link .= '?';
            $link .= http_build_query($data);
            $link .= $this->additionalGetParameters;
        }
        if ($this->debug) {
            die('<a href="' . $link . '">see results</a>');
        }
        $this->controller->redirect($link);
    }

    protected function setVars($data)
    {
<<<<<<< HEAD
        $searchHistoryObject = null;
        $immediateRedirectLink = '';
        $baseClassName = $this->baseClassForBuyables;
        $controller = $this->controller;

        if (! $baseClassName) {
            $baseClassName = EcommerceConfig::get(ProductGroup::class, 'base_buyable_class');
        }

        if (! $baseClassName) {
            user_error("Can not find ${baseClassName} (baseClassName)");
        }

        $singleton = Injector::inst()->get($baseClassName);
        $baseList = $baseClassName::get()->filter(['ShowInSearch' => 1]);
        $ecomConfig = EcommerceDBConfig::current_ecommerce_db_config();

        if ($ecomConfig->OnlyShowProductsThatCanBePurchased) {
            $baseList->filter(['AllowPurchase' => 1]);
        }

        $limitToCurrentSection = false;

        if (isset($data['SearchOnlyFieldsInThisSection']) && $data['SearchOnlyFieldsInThisSection']) {
            $limitToCurrentSection = true;
            if (! $this->productsToSearch) {

                if ($controller) {
                    $this->productsToSearch = $controller->Products();
                }
            }
            if ($this->productsToSearch instanceof DataList) {
                $this->productsToSearch = $this->productsToSearch->map('ID', 'ID')->toArray();
            }
            //last resort
            if ($this->productsToSearch) {
                $baseList = $baseList->filter(['ID' => $this->productsToSearch]);
=======
        $this->rawData = $data;
        if (! $this->maximumNumberOfResults) {
            $this->maximumNumberOfResults = EcommerceConfig::get(ProductGroup::class, 'maximum_number_of_products_to_list_for_search');
        }
        //what is the baseclass?
        $this->baseClassNameForBuyables;
        if (! $this->baseClassNameForBuyables) {
            $this->baseClassNameForBuyables = EcommerceConfig::get(ProductGroup::class, 'base_buyable_class');
        }
        if (isset($data['DebugSearch'])) {
            $this->debug = $data['DebugSearch'] ? true : false;
        }
        if ($this->debug) {
            $this->debugOutput('<hr /><hr /><hr /><h2>Debugging Search Results</h2>');
            $this->debugOutput('<p>Base Class Name: ' . $this->baseClassNameForBuyables . '</p>');
        }
    }

    protected function doKeywordCleanup()
    {
        $isKeywordSearch = true;

        if ($this->debug) {
            $this->debugOutput('<hr /><h3>Raw Keyword ' . $this->keywordPhrase . '</h3><pre>');
        }
        $this->keywordPhrase = Convert::raw2sql($this->keywordPhrase);
        $this->keywordPhrase = strtolower($this->keywordPhrase);
    }

    protected function doAddToSearchHistory()
    {
        SearchHistory::add_entry($this->keywordPhrase);
    }

    protected function doInternalItemSearch()
    {

        ###############################################################
        // 1) Exact search by code
        ###############################################################
        $count = 0;
        if ($this->debug) {
            $this->debugOutput('<hr /><h2>SEARCH BY CODE</h2>');
        }
        $list1 = $this->baseList->filter(['InternalItemID' => $this->keywordPhrase]);
        $count = $list1->count();
        if ($count === 1) {
            // $this->immediateRedirectPage = $list1->First()->getRequestHandler()->Link();
            $this->immediateRedirectPage = $list1->First();
            if ($this->debug) {
                $this->debugOutput('<p style="color: red">Found one answer for potential immediate redirect: ' . $this->immediateRedirectPage->Link() . '</p>');
>>>>>>> master
            }
        }
        if ($count > 0) {
            if ($this->addToResults($list1)) {
                //break;
            }
        }
<<<<<<< HEAD
        //defining some variables
        $isKeywordSearch = false;

        if (isset($data['ShortKeyword']) && ! isset($data['Keyword'])) {
            $data['Keyword'] = $data['ShortKeyword'];
        }

        if (isset($data['Keyword']) && $keywordPhrase = $data['Keyword']) {
            if ($baseList->count()) {
                if (strlen($keywordPhrase) > 1) {
                    $isKeywordSearch = true;
                    $immediateRedirectLink = '';
                    $this->resultArrayPos = 0;
                    $this->resultArray = [];
                    if ($this->debug) {
                        $this->debugOutput('<hr /><h3>Raw Keyword ' . $keywordPhrase . '</h3><pre>');
                    }
                    $keywordPhrase = Convert::raw2sql($keywordPhrase);
                    $keywordPhrase = strtolower($keywordPhrase);
=======
        if ($this->debug) {
            $this->debugOutput("<h3>SEARCH BY CODE RESULT: ${count}</h3>");
        }
    }

    protected function doKeywordReplacements()
    {
        if ($this->immediateRedirectPage === null) {
            if ($this->resultArrayPos < $this->maximumNumberOfResults) {
                $this->replaceSearchPhraseOrWord();
                //now we are going to look for synonyms
                $words = explode(' ', trim(preg_replace('!\s+!', ' ', $this->keywordPhrase)));
                foreach ($words as $word) {
                    //todo: why are we looping through words?
                    $this->replaceSearchPhraseOrWord($word);
                }
                if ($this->debug) {
                    $this->debugOutput('<pre>WORD ARRAY: ' . print_r($this->keywordPhrase, 1) . '</pre>');
                }
            }
        }
    }
>>>>>>> master

    protected function doProductSearch()
    {
        ###############################################################
        // 2) Search for the entire keyword phrase and its replacements
        ###############################################################
        if ($this->immediateRedirectPage === null) {
            $count = 0;
            if ($this->debug) {
                $this->debugOutput('<hr /><h3>FULL KEYWORD SEARCH</h3>');
            }
            if ($this->resultArrayPos < $this->maximumNumberOfResults) {
                $fieldArray = [];
                //work out searches
                $singleton = Injector::inst()->get($this->baseClassNameForBuyables);
                foreach ($this->extraBuyableFieldsToSearchFullText as $tempClassName => $fieldArrayTemp) {
                    if ($singleton instanceof $tempClassName) {
                        $fieldArray = $fieldArrayTemp;
                        break;
                    }
                }
                if ($this->debug) {
                    $this->debugOutput('<pre>FIELD ARRAY: ' . print_r($fieldArray, 1) . '</pre>');
                }

                $searches = $this->getSearchArrays($fieldArray);
                //if($this->debug) { $this->debugOutput("<pre>SEARCH ARRAY: ".print_r($searches, 1)."</pre>");}

                //we search exact matches first then other matches ...
                foreach ($searches as $search) {
                    $list2 = $this->baseList->where($search);
                    $count = $list2->count();
                    if ($this->debug) {
                        $this->debugOutput("<p>${search}: ${count}</p>");
                    }
                    if ($count > 0) {
                        if ($this->addToResults($list2)) {
                            break;
                        }
                    }
                    if ($this->resultArrayPos >= $this->maximumNumberOfResults) {
                        break;
                    }
                }
            }
            if ($this->debug) {
                $this->debugOutput("<h3>FULL KEYWORD SEARCH: ${count}</h3>");
            }
        }
    }

<<<<<<< HEAD
                    // 2) Search for the entire keyword phrase and its replacements
                    $count = 0;

                    if ($this->resultArrayPos < $this->maximumNumberOfResults) {
                        $fieldArray = [];
                        $keywordPhrase = $this->replaceSearchPhraseOrWord($keywordPhrase);
                        //now we are going to look for synonyms
                        $words = explode(' ', trim(preg_replace('!\s+!', ' ', $keywordPhrase)));
                        foreach ($words as $word) {
                            //todo: why are we looping through words?
                            $keywordPhrase = $this->replaceSearchPhraseOrWord($keywordPhrase, $word);
                        }
                        if ($this->debug) {
                            $this->debugOutput('<pre>WORD ARRAY: ' . print_r($keywordPhrase, 1) . '</pre>');
                        }

                        //work out searches
                        foreach ($this->extraBuyableFieldsToSearchFullText as $tempClassName => $fieldArrayTemp) {
                            if ($singleton instanceof $tempClassName) {
                                $fieldArray = $fieldArrayTemp;
                                break;
                            }
                        }
                        if ($this->debug) {
                            $this->debugOutput('<pre>FIELD ARRAY: ' . print_r($fieldArray, 1) . '</pre>');
                        }

                        $searches = $this->getSearchArrays($keywordPhrase, $fieldArray);

                        //we search exact matches first then other matches ...
                        foreach ($searches as $search) {
                            $list2 = $baseList->where($search);
                            $count = $list2->count();
                            if ($this->debug) {
                                $this->debugOutput("<p>${search}: ${count}</p>");
                            }
                            if ($count > 0) {
                                if ($this->addToResults($list2)) {
                                    break;
                                }
                            }
                            if ($this->resultArrayPos >= $this->maximumNumberOfResults) {
                                break;
                            }
                        }
                    }
                    if ($this->debug) {
                        $this->debugOutput("<h3>FULL KEYWORD SEARCH: ${count}</h3>");
                    }
=======
    protected function doGroupSearch()
    {
        ###############################################################
        // 3) Do the same search for Product Group names
        ###############################################################
        if ($this->immediateRedirectPage === null) {
            if ($this->debug) {
                $this->debugOutput('<hr /><h3>PRODUCT GROUP SEARCH</h3>');
            }

            $count = 0;
            //work out searches
            $fieldArray = $this->extraBuyableFieldsToSearchFullText[$this->baseClassNameForGroups];
            if ($this->debug) {
                $this->debugOutput('<pre>FIELD ARRAY: ' . print_r($fieldArray, 1) . '</pre>');
            }
>>>>>>> master

            $searches = $this->getSearchArrays($fieldArray);
            if ($this->debug) {
                $this->debugOutput('<pre>SEARCH ARRAY: ' . print_r($searches, 1) . '</pre>');
            }

            foreach ($searches as $search) {
                $productGroups = ProductGroup::get()->where($search)->filter(['ShowInSearch' => 1]);
                $count = $productGroups->count();
                //redirect if we find exactly one match and we have no matches so far...
                if ($count === 1 && ! $this->resultArrayPos) {
                    $this->immediateRedirectPage = $productGroups->First();
                }
                if ($count > 0) {
                    foreach ($productGroups as $productGroup) {
                        //we add them like this because we like to keep them in order!
                        if (! in_array($productGroup->ID, $this->productGroupIds, true)) {
                            $this->productGroupIds[] = $productGroup->ID;
                        }
                    }
                }
            }
            if ($this->debug) {
                $this->debugOutput("<h3>PRODUCT GROUP SEARCH: ${count}</h3>");
            }
        }
<<<<<<< HEAD
        if (! $isKeywordSearch) {
            $this->addToResults($baseList);
        }

        $redirectToPage = null;

        if (!$limitToCurrentSection) {
            $redirectToPage = ProductGroupSearchPage::get()->first();
        }

        if (!$redirectToPage) {
            // for section specific search,
            // redirect to the specific section (basically where we came from)
            $redirectToPage = $this->controller->dataRecord;
        }

        if ($searchHistoryObject) {
            $searchHistoryObject->ProductCount = count($this->resultArray);
            $searchHistoryObject->GroupCount = count($this->productGroupIDs);
            $searchHistoryObject->write();
        }

        if ($immediateRedirectLink) {
            $link = $immediateRedirectLink;
        } else {
            $link = $redirectToPage->Link($this->controllerSearchResultDisplayMethod);
        }

        if ($this->additionalGetParameters) {
            $link .= '?' . $this->additionalGetParameters;
        }

        $this->controller->redirect($link);
=======
>>>>>>> master
    }

    protected function doProcessResults()
    {
<<<<<<< HEAD
        if (!is_array($data)) {
            $data = $this->getData();
        }

        if (isset($data['MinimumPrice']) && ! $data['MinimumPrice']) {
            unset($data['MinimumPrice']);
        }

        if (isset($data['MaximumPrice']) && ! $data['MaximumPrice']) {
            unset($data['MaximumPrice']);
        }

        if (isset($data['ShortKeyword']) && $data['ShortKeyword']) {
            $data['Keyword'] = $data['ShortKeyword'];
        }

        if (isset($data['Keyword']) && $data['Keyword']) {
            $data['ShortKeyword'] = $data['Keyword'];
        }

        Controller::curr()->getRequest()->getSession()->set($this->Config()->get('form_data_session_variable'), $data);
=======
        //you can add more details here in extensions of this form.
        $this->extend('updateProcessResults');
>>>>>>> master
    }

    /**
     * Creates three levels of searches that can be executed one after the
     * other, each being less specific than the last.
     *
     * returns true when done and false when more are needed
     *
     * @return bool
     */
    protected function addToResults(DataList $listToAdd): bool
    {
        $internalItemID = 0;
        $listToAdd = $listToAdd->limit($this->maximumNumberOfResults - $this->resultArrayPos);
        $listToAdd = $listToAdd->sort('Price', 'DESC');
        foreach ($listToAdd as $page) {
            $id = $page->IDForSearchResults();
            if ($this->debug) {
                $internalItemID = $page->InternalItemIDForSearchResults();
            }
            if ($id) {
                if (! in_array($id, $this->productIds, true)) {
                    ++$this->resultArrayPos;
                    $this->productIds[$this->resultArrayPos] = $id;
                    if ($this->resultArrayPos > $this->maximumNumberOfResults) {
                        return true;
                    }
                }
            }
        }

        return false;
    }

    /**
     * creates three levels of searches that
     * can be executed one after the other, each
     * being less specific than the last...
     *
     * @param array $fields - fields being searched
     *
     * @return array
     */
    protected function getSearchArrays($fields = ['Title', 'MenuTitle']): array
    {
        //make three levels of search
        $searches = [];
        $wordsAsString = preg_replace('!\s+!', ' ', $this->keywordPhrase);
        $wordAsArray = explode(' ', $wordsAsString);
        $hasWordArray = false;
        $searchStringAND = '';
        if (count($wordAsArray) > 1) {
            $hasWordArray = true;
            $searchStringArray = [];
            foreach ($wordAsArray as $word) {
                $searchStringArray[] = "LOWER(\"FFFFFF\") LIKE '%${word}%'";
            }
            $searchStringAND = '(' . implode(' AND ', $searchStringArray) . ')';
            // $searchStringOR = '('.implode(' OR ', $searchStringArray).')';
        }
        // $wordsAsLikeString = trim(implode('%', $wordAsArray));
        $completed = [];
        $count = -1;
        if (in_array('Title', $fields, true)) {
            if ($hasWordArray) {
                $searches[++$count][] = str_replace('FFFFFF', 'Title', $searchStringAND); // d) Words matched individually
                // $searches[++$count + 100][] = str_replace('FFFFFF', 'Title', $searchStringOR); // d) Words matched individually
            }
            $completed['Title'] = 'Title';
        }
        if (in_array('MenuTitle', $fields, true)) {
            $searches[++$count][] = "LOWER(\"MenuTitle\") = '${wordsAsString}'"; // a) Exact match
            $searches[++$count][] = "LOWER(\"MenuTitle\") LIKE '%${wordsAsString}%'"; // b) Full match within a bigger string
            if ($hasWordArray) {
                $searches[++$count][] = str_replace('FFFFFF', 'MenuTitle', $searchStringAND); // d) Words matched individually
                // $searches[++$count + 100][] = str_replace('FFFFFF', 'MenuTitle', $searchStringOR); // d) Words matched individually
            }
            $completed['MenuTitle'] = 'MenuTitle';
        }
        if (in_array('MetaTitle', $fields, true)) {
            $searches[++$count][] = "LOWER(\"MetaTitle\") = '${wordsAsString}'"; // a) Exact match
            $searches[++$count][] = "LOWER(\"MetaTitle\") LIKE '%${wordsAsString}%'"; // b) Full match within a bigger string
            if ($hasWordArray) {
                $searches[++$count][] = str_replace('FFFFFF', 'MetaTitle', $searchStringAND); // d) Words matched individually
                // $searches[++$count + 100][] = str_replace('FFFFFF', 'MetaTitle', $searchStringOR); // d) Words matched individually
            }
            $completed['MetaTitle'] = 'MetaTitle';
        }
        foreach ($fields as $field) {
            if (! isset($completed[$field])) {
                $searches[++$count][] = "LOWER(\"${field}\") = '${wordsAsString}'"; // a) Exact match
                $searches[++$count][] = "LOWER(\"${field}\") LIKE '%${wordsAsString}%'"; // b) Full match within a bigger string
                if ($hasWordArray) {
                    $searches[++$count][] = str_replace('FFFFFF', $field, $searchStringAND); // d) Words matched individually
                    // $searches[++$count + 100][] = str_replace('FFFFFF', $field, $searchStringOR); // d) Words matched individually
                }
            }
        }
        ksort($searches);
        $returnArray = [];
        foreach ($searches as $key => $search) {
            $returnArray[$key] = implode(' OR ', $search);
        }

        return $returnArray;
    }

    /**
     * @param  string $word (optional word within keywordPhrase)
     *
     * @return string (updated Keyword Phrase)
     */
    protected function replaceSearchPhraseOrWord(?string $word = '')
    {
        if (! $word) {
            $word = $this->keywordPhrase;
        }
        $replacements = SearchReplacement::get()
            ->where(
                "
                LOWER(\"Search\") = '${word}' OR
                LOWER(\"Search\") LIKE '%,${word}' OR
                LOWER(\"Search\") LIKE '${word},%' OR
                LOWER(\"Search\") LIKE '%,${word},%'"
            );
        //if it is a word replacement then we do not want replace whole phrase ones ...
        if ($this->keywordPhrase !== $word) {
            $replacements = $replacements->exclude(['ReplaceWholePhrase' => 1]);
        }
        if ($replacements->count()) {
            $replacementsArray = $replacements->map('ID', 'Replace')->toArray();
            if ($this->debug) {
                $this->debugOutput("found alias for ${word}");
            }
            foreach ($replacementsArray as $replacementWord) {
                $this->keywordPhrase = str_replace($word, $replacementWord, $this->keywordPhrase);
            }
        }
    }

    protected function getResultsPage()
    {
        //if no specific section is being searched then we redirect to search page:
        return DataObject::get_one(ProductGroupSearchPage::class);
    }

    protected function createBaseList()
    {
        $tmpVar = $this->baseClassNameForBuyables;
        $this->baseList = $tmpVar::get()->filter(['ShowInSearch' => 1]);
        $ecomConfig = EcommerceDBConfig::current_ecommerce_db_config();
        if ($ecomConfig->OnlyShowProductsThatCanBePurchased) {
            $this->baseList->filter(['AllowPurchase' => 1]);
        }
    }

    protected function getSerializedObject(?array $data = [])
    {
        $variables = get_object_vars($this);
        foreach ($variables as $key => $values) {
            if (is_object($value)) {
                if (empty($object->ClassName) || empty($object->ID)) {
                    unset($variables[$key]);
                } else {
                    $variables[$key] = $object->ClassName . '_' . $object->ID;
                }
            }
        }
        return serialize($variables);
    }

    /**
     * @param  string $data optional
     * @return float
     */
    protected function getHash(?string $data = '')
    {
        if (! $data) {
            $data = $this->getSerializedObject();
        }
        return crc32($data);
    }

    protected function setCacheForHash(): float
    {
        $cache = $this->getCache();
        $data = $this->getSerializedObject();
        $hash = $this->getHash($data);
        $cache->set($hash, $data);

        return $hash;
    }

    protected function getCacheForHash(string $hash): array
    {
        $array = [];
        $cache = $this->getCache();
        if ($cache->has($hash)) {
            $array = $cache->get($hash);
            if (! is_array($array)) {
                $array = [];
            }
        }

        return $array;
    }

    protected function applyCacheFromHash(string $hash): array
    {
        $string = $this->getCache($hash);
        $array = unserialize($hash);
        foreach ($array as $variable => $value) {
            $this->{$variable} = $value;
        }
        return $array;
    }

    protected function getCache(): CacheInterface
    {
        return Injector::inst()->get(CacheInterface::class . '.EcomSearchCache');
    }

<<<<<<< HEAD
    /**
     * Returns all the {@link ProductGroups} which are matched in this search
     * form.
     *
     */
    public function getProductGroups(): DataList
    {
        // @todo
        return ProductGroup::get();
    }

    /**
     * @return array
     */
    public function getSessionData(): array
=======
    protected function debugOutput(string $string)
>>>>>>> master
    {
        $data = Controller::curr()->getRequest()->getSession()->get(
            Config::inst()->get(ProductSearchForm::class, 'form_data_session_variable')
        );

        if (!$data) {
            return [];
        }

        return $data;
    }
}
